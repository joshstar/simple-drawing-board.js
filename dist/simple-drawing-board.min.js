!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).SimpleDrawingBoard={})}(this,(function(t){"use strict";class e{constructor(){this._events={}}on(t,e){const s=this._events;t in s||(s[t]=[]),s[t].push(e)}off(t,e){const s=this._events;if(!(t in s))return;e||(s[t]=[]);const o=s[t].indexOf(e);o>=0&&s[t].splice(o,1)}trigger(t,e){const s=this._events;if(t in s)for(let o=0;o<s[t].length;o++){const i=s[t][o];i.handleEvent?i.handleEvent.call(this,e):i.call(this,e)}}removeAllListeners(){this._events={}}}class s{constructor(t=null){this._past=[],this._present=t,this._future=[]}get value(){return this._present}undo(){if(0===this._past.length)return;const t=this._past.pop();this._future.unshift(this._present),this._present=t}redo(){if(0===this._future.length)return;const t=this._future.shift();this._past.push(this._present),this._present=t}save(t){this._present!==t&&(this._past.push(this._present),this._future.length=0,this._present=t)}clear(){this._past.length=0,this._future.length=0}}function o(){return"ontouchstart"in window.document}function i(t){return"string"==typeof t&&!!t.startsWith("data:image/")}async function r(t){return new Promise((e,s)=>{const o=new Image;o.onerror=s,o.onload=()=>e(o),o.src=t})}function n(t,e){return{x:t.x+e.x>>1,y:t.y+e.y>>1}}function a(t,e){let s,i;o()?(s=t.touches[0].pageX,i=t.touches[0].pageY):(s=t.pageX,i=t.pageY);const r=e.getBoundingClientRect(),n=r.left+window.pageXOffset,a=r.top+window.pageYOffset;return{x:(s-n)*(e.width/r.width),y:(i-a)*(e.height/r.height)}}class h{constructor(t){this._$el=t,this._ctx=this._$el.getContext("2d"),this._ctx.lineCap=this._ctx.lineJoin="round",this._isDrawMode=!0,this._isDrawing=!1,this._isFloodMode=!1,this._timer=null,this._coords={old:{x:0,y:0},oldMid:{x:0,y:0},current:{x:0,y:0}},this._ev=new e,this._history=new s(this.toDataURL()),this._bindEvents(),this._drawFrame()}get canvas(){return this._$el}get observer(){return this._ev}get mode(){return this._isDrawMode?"draw":"erase"}setLineSize(t){this._ctx.lineWidth=0|t||1}setLineColor(t){this._ctx.strokeStyle=t}fill(t){const e=this._ctx;e.clearRect(0,0,e.canvas.width,e.canvas.height),e.fillStyle=t,e.fillRect(0,0,e.canvas.width,e.canvas.height),this._saveHistory()}clear(){const t=this._ctx;t.clearRect(0,0,t.canvas.width,t.canvas.height),this._saveHistory()}toggleMode(){this._ctx.globalCompositeOperation=this._isDrawMode?"destination-out":"source-over",this._isDrawMode=!this._isDrawMode}setMode(t){const e={draw:"source-over",erase:"destination-out",flood:"source-over"};if(!e[t])throw new Error('Invalid mode argument provided to function "setMode".\n\t\t\t\tValid values are: "draw", "erase", "flood"');this._ctx.globalCompositeOperation=e[t],this._isFloodMode="flood"===t,this._isDrawMode="draw"===t}toDataURL({type:t,quality:e}={}){return this._ctx.canvas.toDataURL(t,e)}fillImageByElement(t,{isOverlay:e=!1}={}){if(!function(t){return t instanceof HTMLImageElement||t instanceof SVGImageElement||t instanceof HTMLCanvasElement||t instanceof HTMLVideoElement}(t))throw new TypeError("Passed element is not a drawable!");const s=this._ctx;e||s.clearRect(0,0,s.canvas.width,s.canvas.height),s.drawImage(t,0,0,s.canvas.width,s.canvas.height),this._saveHistory()}async fillImageByDataURL(t,{isOverlay:e=!1}={}){if(!i(t))throw new TypeError("Passed src is not a base64 data URL!");const s=await r(t),o=this._ctx;e||o.clearRect(0,0,o.canvas.width,o.canvas.height),o.drawImage(s,0,0,o.canvas.width,o.canvas.height),this._saveHistory()}async undo(){this._history.undo();const t=this._history.value;if(!i(t))return;const e=await r(t),s=this._ctx;s.clearRect(0,0,s.canvas.width,s.canvas.height),s.drawImage(e,0,0,s.canvas.width,s.canvas.height)}async redo(){this._history.redo();const t=this._history.value;if(!i(t))return;const e=await r(t),s=this._ctx;s.clearRect(0,0,s.canvas.width,s.canvas.height),s.drawImage(e,0,0,s.canvas.width,s.canvas.height)}destroy(){this._unbindEvents(),this._ev.removeAllListeners(),this._history.clear(),cancelAnimationFrame(this._timer),this._timer=null}handleEvent(t){switch(t.preventDefault(),t.stopPropagation(),t.type){case"mousedown":case"touchstart":this._onInputDown(t);break;case"mousemove":case"touchmove":this._onInputMove(t);break;case"mouseup":case"touchend":this._onInputUp();break;case"mouseout":case"touchcancel":case"gesturestart":this._onInputCancel()}}_bindEvents(){const t=o()?["touchstart","touchmove","touchend","touchcancel","gesturestart"]:["mousedown","mousemove","mouseup","mouseout"];for(const e of t)this._$el.addEventListener(e,this,!1)}_unbindEvents(){const t=o()?["touchstart","touchmove","touchend","touchcancel","gesturestart"]:["mousedown","mousemove","mouseup","mouseout"];for(const e of t)this._$el.removeEventListener(e,this,!1)}_drawFrame(){if(this._timer=requestAnimationFrame(()=>this._drawFrame()),!this._isDrawing)return;if(this._isFloodMode)return this._flood();const t=this._coords.old.x===this._coords.current.x&&this._coords.old.y===this._coords.current.y,e=n(this._coords.old,this._coords.current),s=this._ctx;s.beginPath(),s.moveTo(e.x,e.y),s.quadraticCurveTo(this._coords.old.x,this._coords.old.y,this._coords.oldMid.x,this._coords.oldMid.y),s.stroke(),this._coords.old=this._coords.current,this._coords.oldMid=e,t||this._ev.trigger("draw",this._coords.current)}_onInputDown(t){this._isDrawing=!0;const e=a(t,this._$el);this._coords.current=this._coords.old=e,this._coords.oldMid=n(this._coords.old,e),this._ev.trigger("drawBegin",this._coords.current)}_onInputMove(t){this._coords.current=a(t,this._$el)}_onInputUp(){this._ev.trigger("drawEnd",this._coords.current),this._saveHistory(),this._isDrawing=!1}_onInputCancel(){this._isDrawing&&(this._ev.trigger("drawEnd",this._coords.current),this._saveHistory()),this._isDrawing=!1}_saveHistory(){this._history.save(this.toDataURL()),this._ev.trigger("save",this._history.value)}_flood(){this._isDrawing=!1;const{width:t,height:e}=this._ctx.canvas,s=this._ctx.getImageData(0,0,t,e),{x:o,y:i}=this._coords.current,r=[[o,i]],n=this._ctx.getImageData(Math.floor(o),Math.floor(i),1,1).data,a=this._getFloodColor();if(n[0]!==a.r||n[1]!==a.g||n[2]!==a.b||n[3]!==a.a){for(;r.length;){const o=r.pop(),i=Math.floor(o[0]);let c=Math.floor(o[1]),d=4*(c*t+i),l=!1,u=!1;for(;c>=0&&this._matchStartColor(s,d,n);)c-=1,d-=4*t;for(d+=4*t,c+=1;c<e&&this._matchStartColor(s,d,n);)h(d,a),i>0&&(this._matchStartColor(s,d-4,n)?l||(r.push([i-1,c]),l=!0):l&&(l=!1)),i<t-1&&(this._matchStartColor(s,d+4,n)?u||(r.push([i+1,c]),u=!0):u&&(u=!1)),c+=1,d+=4*t}this._ctx.putImageData(s,0,0)}function h(t,{r:e,g:o,b:i,a:r}){s.data[t]=e,s.data[t+1]=o,s.data[t+2]=i,s.data[t+3]=r}}_matchStartColor(t,e,s){const o=t.data,[i,r,n,a]=[o[e],o[e+1],o[e+2],o[e+3]];return 255!==a||i===s[0]&&r===s[1]&&n===s[2]&&a===s[3]}_getFloodColor(){const t=this._ctx,e=t.getImageData(0,0,1,1);t.fillStyle=t.strokeStyle,t.fillRect(0,0,1,1);const s=t.getImageData(0,0,1,1);t.fillStyle=`rgba(${e[0],e[1],e[2],e[3]})`,t.fillRect(0,0,1,1);const[o,i,r,n]=s.data;return{r:o,g:i,b:r,a:n}}}t.create=function(t){if(!(t instanceof HTMLCanvasElement))throw new TypeError("HTMLCanvasElement must be passed as first argument!");return new h(t)},Object.defineProperty(t,"__esModule",{value:!0})}));
